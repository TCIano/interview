
# 💡CSS
### 🔺水平垂直居中一个元素

1. flex:主轴：
```javascript
justify-content：center
align-item：center
```

2. margin+定位：
```javascript
position:absolute
top:50%
left:50%
margin-left:width/2
margin-top:height/2
```

3. transform平面转换（translate）+定位
```javascript
position:absolute
top:50%
left:50%
translate：（-50%，-50%）
```

### CSS盒子模型

1. css盒子模型就是一个盒子：margin+border+padding+content

W3C（标准盒子模型）：
width /height = content

   1. 设置border/padding会使盒子变大
   1. box-sizing : content-box

IE（怪异盒子模型）
width/heigth = content + border +padding

   1. box-sizing ：border-box

### CSS3新属性

1. 文字阴影：	text-shadow :  水平  垂直  模糊距离  颜色
1. 圆角矩形：（长方形）border-radius ：height/2

正圆： （正方形）border-radius ：height/2
胶囊： （长方形）border-radius ：>=height/2
椭圆： （长方形）border-radius ：height/2
半圆：	（）border-radius ：**px(左上)	0(右上)	0(右下)	**px(左下) 

3. 盒子阴影：	box-shadow：水平  垂直  模糊距离  阴影大小  颜色	改变内侧阴影
3. 过渡动画：	(加在做动画的盒子上) 

transition：要改变的过渡属性/all(所有属性)		运动曲线(ease/linear)	延时

5. background-size：cover (让背景图完全撑满长和宽)

      contain(高/宽其中一个与盒子一致就停止缩放)

### 🔺BFC(块级格式化上下文 )	
是一个独立的布局区域，子元素不会影响外界元素，也不受外界的影响
特点：在BFC中盒子沿着顶端垂直排列,根元素 BFC区域，浮动和绝对 定位的元素也会形成BFC区域
作用：清除浮动（子元素浮动的同时，父元素没设置高度 ，这样不会被子元素撑开）
```javascript
  <div class="container">
      <div class="Sibling">子元素1</div>
      <div class="Sibling">子元素2</div>
  </div>
```
```javascript
 .container {
        /* 开启BFC */
        /* overflow: hidden; */
        display: flex;
        /* height: 60px; */

        background-color: green;
      }
      .container .Sibling {
        float: left;
        /* width: 20px;
        height: 20px; */
        margin: 10px;
        background-color: lightgreen;
      }
```
 不开启BFC
![image.png](https://cdn.nlark.com/yuque/0/2022/png/29071883/1656494334459-502fdcbc-5e52-4b7b-a25f-2fbfd41ed38d.png#clientId=u637a6d6a-819d-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=97&id=ue384074a&margin=%5Bobject%20Object%5D&name=image.png&originHeight=121&originWidth=384&originalType=binary&ratio=1&rotation=0&showTitle=false&size=2046&status=done&style=stroke&taskId=ue01b7932-af37-49cb-8282-0c99c9b7595&title=&width=307.2)
开启BFC
![image.png](https://cdn.nlark.com/yuque/0/2022/png/29071883/1656494393293-910ced73-6168-4f28-b324-2c8b2ab661be.png#clientId=u637a6d6a-819d-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=98&id=u49195494&margin=%5Bobject%20Object%5D&name=image.png&originHeight=122&originWidth=355&originalType=binary&ratio=1&rotation=0&showTitle=false&size=2112&status=done&style=stroke&taskId=ud8cbb1ed-3a8d-46f6-8c42-0cf58b29cdf&title=&width=284)
 解决外边距塌陷问题
开启：display：flow-root
inline-block
flex
overflow：hidden

### 单行文本省略
省略前要确定元素要有宽度 ，并且文本内容超过了元素内容。
overflow: hidden 给文本所在的标签使用，
text-overflow: ellipsis; （文本溢出时候，用省略号表示）依赖上一句的存在 
 white-space: nowrap;（规定元素内的空白怎么处理）nowrap表示不换行
```javascript
    p {   
        width: 200px;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
    {
```

### flex布局(弹性布局)
开启：display：flex
主轴对齐方式：justify-content: space-between（每个盒子之间的距离一样）
space-around(每个盒子周围的空间)
space-evenly(平分剩余空间)
侧轴对齐方式：align-item: flex-start (起点开始默认)
flex-end(终点开始排列 )
center
      align-self:(某个盒子的侧轴对齐方式)
弹性盒子换行：flex-wrap：wrap；
wrap-reverse；（第一行在最后）

flex-grow :(定义放大比例)、flex-shrink(定义 缩小比例)、flex-basis(分配多余空间之前，子项目占据的主轴空间)
flex:auto = {flex-grow: 1;flex-shrink: 1;flex-basis:auto}
flex:none = {flex-grow: 0;flex-shrink: 0;flex-basis:auto}
flex:1 = {flex-grow: 1;flex-shrink: 1;flex-basis:0%}
flex：1 (更适合在等比例的列表中使用)
flex：auto(适用于元素充分利用的剩余空间，内部都一样才均分)

### 清除浮动

1. 给浮动元素的父级加  overflow：hidden
1. 在浮动的子元素最后加个空标签写 clear：both
1. 用after伪元素(相当于加一个空标签)
1. 给父级设置高度
### 🔺外边距塌陷解决

1. 给子元素加 position：absolute（变为行内块）
1. 父元素加overflow：hidden
1. 给父元素加border-top/padding-top
1. 设置浮动：display：float

# 💡html
### HTML5新特性

1. canvas(通过javascript图形绘制)
1. video和audio(音频视频标签)
1. 表单元素：datalist(选项列表，和input配合使用)，keygen(表单秘钥)，output(脚本输出)
1. 语义，结构元素：article(定义页面独立区域)，footer(页脚)，	header(文档头部区域)，nav(导航链接)，section(定义文档中的节)
1. 新技术：websocket(全双工通信)，webWorkers（Web应用程序可以在独立于主线程的后台线程中，运行一个脚本操作。这样做的好处是可以在独立线程中执行费时的处理任务，从而允许主线程（通常是UI线程）不会因此被阻塞/放慢），Geolocation（用户地理信息）
1. localstorage：本地存储，浏览器关闭后不会丢失
1. sessionstorage：浏览器关闭后数据消失
1. 离线应用：Cache manifest （进行web应用的缓存）
1. 移除了：basefont、big、center、font、s、strike、tt、u

frame、frameset、noframes
### 页面导入样式时，使用 link 和 @import 有什么区别

1. 从属关系：

@import 是 css 提供的语法规则，只有导入样式表的作用。
link 是html提供的标签不仅可以加载 css 文件，可以连接属性，引入网站图标

2. 加载顺序：

@import 引入的 css 将在页面加载完成后被加载。
加载页面时 link 引入的 css 也被同时加载

3. 兼容性：

@import  是 css 2.1 之后有的，只能在IE5及以上可用
link 没有兼容性问题

4. Dom可控性：

可以通过 JS 操作 DOM ，插入 link 标签来改变样式，由于 DOM 方法是基于文档的，无法使用 @import 的方式插入样式。

###  前端性能优化主要是为了提高页面的加载速度，优化用户的访问体验。我认为可以从这些方面来进行优化。

 第一个方面是页面的内容方面
 （1）通过文件合并、css 雪碧图、使用 base64 等方式来减少 HTTP 请求数，避免过多的请求造成等待的情况。
 （2）通过 DNS 缓存等机制来减少 DNS 的查询次数。
 （3）通过设置缓存策略，对常用不变的资源进行缓存。
 （4）使用延迟加载的方式，来减少页面首屏加载时需要请求的资源。延迟加载的资源当用户需要访问时，再去请求加载。
 （5）通过用户行为，对某些资源使用预加载的方式，来提高用户需要访问资源时的响应速度。
	
第二个方面是 CSS 和 JavaScript 方面
 （1）把样式表放在页面的 head 标签中，减少页面的首次渲染的时间。
 （2）避免使用 @import 标签。
 （3）尽量把 js 脚本放在页面底部或者使用 defer 或 async 属性，避免脚本的加载和执行阻塞页面的渲染。
 （4）通过对 JavaScript 和 CSS 的文件进行压缩，来减小文件的体积。

 第三个方面是服务器方面
 （1）使用 CDN 服务，来提高用户对于资源请求时的响应速度。
 （2）服务器端启用 Gzip、Deflate 等方式对于传输的资源进行压缩，减小文件的体积。
 （3）尽可能减小 cookie 的大小，并且通过将静态资源分配到其他域名下，来避免对静态资源请求时携带不必要的 cookie

 
### 🔺DOMContentLoaded事件/Load事件的区别？
DOMContentLoaded事件：HTML页面文档(DOM元素)加载和解析完毕后会触发，不需要等待样式表、图片、框架加载完毕。
Load：当所有资源加载玩比后触发。


# 💡js 
### 🔺JS的数据类型

- 栈：原始数据类型（Undefined、Null、Boolean、Number、String，symbol，BigInt）
- 堆：引用数据类型（对象、数组和函数，Date）

### 🔺原型对象，原型链

1. 原型

当我们用构造函数创建新对象时，函数的内部都有一个prototype属性，我们可以把函数的方法直接定义在prototype对象上，这样所有的对象的实例都可以共享这些方法。
每个被创建的实例对象内部都有一个__proto__属性，他们都指向各自的构造函数的prototype原型对象。

2. 原型链（就近原则）

当我们访问一个对象的属性或者方法的时候如果实例化对象内部没有这个属性和方法，我们就可以通过__proto__找到他的原型对象，如果还没有就找到原型对象的Object原型对象，直到找到null为止。

### 同源、同源策略、跨域

1. 同源：两个页面有相同的协议、域名、端口
1. 同源策略：是浏览器提供的一个安全策略，他规定了：
   1. 不可以读取非同源网站的Cookie、Localstorage、IndexedDB
   1. 无法获取非同源网页的DOM
   1. 无法向非同源地址发送Ajax请求
3. 跨域 ：浏览器的同源策略不允许非同源的URL之间进行交互

怎么跨域：JSONP ：缺点：只支持GET，不支持POST
     CORS：优：GET和POST都支持，
     缺：不兼容低版本浏览器
      开启反向代理服务器：一个网页通过访问反向代理服务器，间接的访问另
一个网页。

### 模块化开发
一个模块是对实现一个特定功能的一组方法的封装。在最开始的时候，js 只实现一些简单的功能，所以并没有模块的概念 ，但随着程序越来越复杂，代码的模块化开发变得越来越重要。
由于函数具有独立作用域的特点，最原始的写法是使用函数来作为模块，几个函数作为一个模块，但是这种方式容易造成全局变量的污染，并且模块间没有联系。 
后面提出了对象写法，通过将函数作为一个对象的方法来实现，这样解决了直接使用函数作为模块的一些缺点，但是这种办法会暴露所 有的所有的模块成员，外部代码可以修改内部属性的值。 
现在最常用的是立即执行函数的写法，通过利用闭包来实现模块私有作用域的建立，同时不会对全局作用域造成污染。

### JS中的几种模块化

1. commonJS：通过require来引入模块，通过module.exports来暴露（导出）模块的输出接口，它是一种服务器端的解决方法，在本地的用同步的方法引入模块 ，如果在浏览器端，由于模块的加载使用网络请求，那么用异步的方式加载更为合适。
1. AMD：采用异步加载的方式，加载模块，模块的加载不影响后面代码的执行，所有依赖这个模块的语句都定义在一个回调函数里，等到加载玩再执行回调函数，require.js就实现了AMD规范。（只适用于浏览器端）
1. CMD：也是采用异步加载的方法，区别在于模块定义都时候对依赖的处理不同和对依赖模块的执行时机的处理不同。（只适用于浏览器端）
1. ES6：用import和export的形式来导入和导出模块。

在编译时就完成模块的加载，效率要比 CommonJS 模块的加载方式高，这也导致了没法引用 ES6 模块本身，因为它不是对象。

### Set和Map数据结构

1. Set（类似于数组）

特点：成员的值唯一，没有重复的值，可以用来数组去重，[...new Set(array)]，可以接受数组或者伪数组作为参数。
声明：new Set（）	
方法：添加成员：add（）
    判断成员是否存在：has（）
    删除成员返回布尔：delete（）
    清除set：clear（）
    遍历set：foreach（）

2. WeakSet（和Set类似）

特点：首先成员只能是对象，其次WeakSet 中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中。
```javascript
let ws = new WeakSet();
      ws.add({
        name: "张三",
        age: 18,
      });
      ws.add({
        name: "李四",
        age: 20,
      });
      console.log(ws);
```
![image.png](https://cdn.nlark.com/yuque/0/2022/png/29071883/1655812443512-070157e2-68a8-43b1-9a19-7d8a83dae27e.png#clientId=u25ad8f7c-0ed8-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=146&id=uaabb66e9&margin=%5Bobject%20Object%5D&name=image.png&originHeight=182&originWidth=483&originalType=binary&ratio=1&rotation=0&showTitle=true&size=13486&status=done&style=none&taskId=u18c8fc3a-3d27-4b69-9e8b-01b3a7734ca&title=WeakSet%E7%BB%93%E6%9E%9C%E5%A6%82%E5%9B%BE&width=386.4 "WeakSet结果如图")

3. Map(像对象，但是键（key）能为任意类型的值)

声明：new Map（）
方法：添加成员：set（key，value）
    判断成员是否存在：has(key)
    获取成员的值：get（key）
    删除成员 ：delete（key）
    返回Map结构成员：size
    清除所有成员，没有返回值：clear（）
```javascript
let o = {
        userm: "wer",
      };
      let map = new Map();
      map.set(o, "age");
      console.log(map.get(o));
      console.log(map.has(o));
      //   map.delete(o);
      console.log(map);
```

![image.png](https://cdn.nlark.com/yuque/0/2022/png/29071883/1655880245884-985dd254-fe2d-45dc-ad16-1d1ab2134931.png#clientId=u0415d881-43bb-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=205&id=JFXgA&margin=%5Bobject%20Object%5D&name=image.png&originHeight=256&originWidth=308&originalType=binary&ratio=1&rotation=0&showTitle=true&size=13609&status=done&style=none&taskId=u201eaf28-6df8-4c52-b62c-100349460c1&title=Map%E6%93%8D%E4%BD%9C%E7%9A%84%E7%BB%93%E6%9E%9C&width=246.4 "Map操作的结果")

4. WeakMap（）

WeakMap只接受对象作为键名（null除外），不接受其他类型的值作为键名。
```javascript
// WeakMap 可以使用 set 方法添加成员
const wm1 = new WeakMap();
const key = {foo: 1};
wm1.set(key, 2);
wm1.get(key) // 2

// WeakMap 也可以接受一个数组，
// 作为构造函数的参数
const k1 = [1, 2, 3];
const k2 = [4, 5, 6];
const wm2 = new WeakMap([[k1, 'foo'], [k2, 'bar']]);
wm2.get(k2) // "bar"
```

### 🔺防抖和节流

1. 防抖：规定一个事件每隔n秒执行一次，如果在n秒内再次执行该事件，则重新开始计时。

防抖函数里面设置定时器，定时器里面做防抖函数的调用，如果在n秒内主动触发，则会重新调用计时器，重新开始计时。
```javascript
if (this.timer) {
        clearTimeout(this.timer);
      }
      this.timer = setTimeout(async () => {
        this.page = 1;
        this.finished = false;
        //如果输入框内容为空，则不显示 搜索到的列表(让列表数组为空)
        if (this.value.trim().length == 0) {
          return (this.searchSongList = []);
        }
        //调用getList 返回promise
        this.searchSongList = await this.getList(this.value);
        // this.timer = null;
      }, 1000);
```

2. 节流 ：规定一个事件在n秒内只能被触发一次，如果在n秒内再次触发，只有一次生效。

节流减少了一段时间内事件的触发频率。
```javascript
 if (this.cando == false) {
        return;
      }
      this.cando = false;
      setTimeout(async () => {
        this.cando = true;
        this.page = 1;
        this.finished = false;
        //如果输入框内容为空，则不显示 搜索到的列表(让列表数组为空)
        if (this.value.trim().length == 0) {
          return (this.searchSongList = []);
        }
        //调用getList 返回promise
        this.searchSongList = await this.getList(this.value);
        // this.timer = null;
      }, 1000);
```

### 🔺对象的深浅拷贝

1. 浅拷贝：

是将一个对象的属性值赋值给另一个对象，如果属性值为引用数据类型，那么会把该引用的地址复制给另一个对象，如果修改一个对象的引用类型的属性值，另一个对象也随之改变。
```javascript
var obj = {
        id: 1,
        name: "章三",
        msg: {
          age: 18,
        },
        color: ["red", "green", "yellow"],
      };

      var o = {};
      // 浅拷贝
      for (var k in obj) {
        o[k] = obj[k];
      }
      o.id = 66;
      o.color[0] = "123";//obj[0] == '123'
      console.log(o);
      console.log(obj);
```
```javascript
Object.assign(o, obj);//展开运算符，把obj浅拷贝给o
      o.id = 989;
      console.log(o);//id = 989
      console.log(obj);

```

1. 深拷贝

遇到属性值为引用类型的时候，它会新建一个引用类型并将对应的值复制给它，对象获得的一个新的引用类型而不是一个原有类型的引用。
```javascript
//深拷贝;
       function deepCopy(newObj, oldObj) {
        for (var k in oldObj) {
          //   console.log(oldObj[k]);
          //如果旧元素里面的元素是对象
          if (oldObj[k] instanceof Array) {
            newObj[k] = [];
            //再遍历对象，里面的元素，对里面元素进行判断
            deepCopy(newObj[k], oldObj[k]);
          }
          //如果里面的元素是数组
          else if (oldObj[k] instanceof Object) {
            //把新元素开辟一个数组空间用来存放旧元素
            newObj[k] = {};
            deepCopy(newObj[k], oldObj[k]);
          }
          //如果是简单数类型
          else {
            newObj[k] = oldObj[k];
          }
        }
      }
      deepCopy(obj, o);
      deepCopy(o, obj);
      o.color[0] = "green";
      o.msg.age = 666;
      console.log(o);
      console.log(obj);
```
```javascript
let a = {
    age: 1,
    jobs: {
        first: 'FE'
    }
}
let b = JSON.parse(JSON.stringify(a))
a.jobs.first = 'native'
console.log(b.jobs.first) // FE
```

### 🔺Promise
Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。Promise是一个对象。
const p = new Promise((resolve, reject) => {})
可以 创建一个Promise 的实例对象，包含resolve（解析） 和 reject（拒绝） 两个参数的回调，如果一切正常那就调用resolve，否则调用reject
p.then(）函数可以 放入成功或者失败的回调函数
```javascript
const p = new Promise((resolve, reject) => {
  //   resolve(1);
  resolve(1);
});
p.then((res, err) => {
  //   console.log(res);
  console.log(res);
  return 11;
})
  .then((res) => {
    console.log(res);
    return new Promise((resolve, reject) => {
      resolve(111);
    });
  })
  .then((res) => {
    console.log(res);
  });
```
![image.png](https://cdn.nlark.com/yuque/0/2022/png/29071883/1656137275745-5a7e664f-acb0-4306-b828-2ca5314a7163.png#clientId=u5f9cc778-2fad-4&crop=0&crop=0.1158&crop=1&crop=1&from=paste&height=112&id=u51df6de6&margin=%5Bobject%20Object%5D&name=image.png&originHeight=72&originWidth=109&originalType=binary&ratio=1&rotation=0&showTitle=true&size=1080&status=done&style=none&taskId=u8b632a9b-577c-458b-9b15-58feacf3bcb&title=%E7%BB%93%E6%9E%9C%E5%9B%BE&width=170 "结果图")
.then() 的返回值可以是promise对象，也可以是一个值
.catch() 用来捕获对象

### async 和 await
用来简化promise操作 
```javascript
import fs, { truncate } from "fs";

const getFile = (fpath) => {
  //返回一个promise对象
  return new Promise((resolve, reject) => {
    //读取文件
    fs.readFile(fpath, "utf8", (err, data) => {
      //如果失败，就返回错误
      if (err) return reject(err);
      resolve(data);
    });
  });
};

const getFiles = async () => {
  const f1 = await getFile("./files/1.txt");
  const f2 = await getFile("./files/2.txt");
  const f3 = await getFile("./files/3.txt");
  console.log(f1, f2, f3);
};
getFiles();//111,222,333
```

1. 如果在函数中使用了 await，则方法要是用 async 来修饰。
1. 在 async 中第一个 await 之前的代码会同步执行，await 之后的代码会异步执行。
1. await 等待的也是 promise 对象。
1. promise.all（）发起并行的promise 异步操作 ，等待全部完成就返回（等待机制）
1. promise.race（）只要有一个操作成功，那就 立马返回，不会等待其他的。

异步任务又分为：宏任务和微任务 
宏任务：异步AJax请求、setTimeout、setInterval、文件操作
微任务 ：promise.then（）、.catch（）、finally（）、process.nextTick
每个宏任务执行完成之后欧，检查是否存在等待执行的微任务，如有，执行完成所有的微任务，继续一下个宏任务。
```javascript
Promise.resolve()
  .then(() => {
    console.log(0);
    return Promise.resolve(100);
  })
  .then((res) => {
    console.log(res);
  });

Promise.resolve().then(() => {
  console.log(1);
});

console.log(777);

setTimeout(() => {
  console.log(888);
}, 3000);

setTimeout(() => {
  console.log(999);
}, 0);
```
![image.png](https://cdn.nlark.com/yuque/0/2022/png/29071883/1656156893008-9deac066-463b-402d-a5e4-68cbfe72ab5f.png#clientId=u1059de3f-6363-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=96&id=Y1gHo&margin=%5Bobject%20Object%5D&name=image.png&originHeight=120&originWidth=307&originalType=binary&ratio=1&rotation=0&showTitle=true&size=1679&status=done&style=stroke&taskId=u7f4ba2ca-6a72-45aa-81f8-b72a957172e&title=%E7%BB%93%E6%9E%9C&width=245.6 "结果")
整个程序 是一个大的宏任务，先从上到下执行里面的同步任务，777为宏任务，再执行下面的微任务，0 和 1 为同一级的微任务，先执行，100为下一级微任务，紧接着执行，然后没有微任务 之后，查询其他宏任务，0s的定时器先执行，所以先执行 999，再执行888

### intanceof 判断复杂数据类型
实现原理：实例对象是否可以根据原型链找到构造函数的原型，如果可以找到就返回true，如果找不到就返回false。
```javascript
 //判断实例对象是否可以根据原型链找到对应的构造函数的原型对象
      const _instanceof = (target, Fn) => {
        // 补全代码
        let targetProto = target.__proto__;
        let fnProto = Fn.prototype;
        console.log(targetProto, fnProto);
        while (true) {
          if (targetProto == fnProto) {
            return true;
          }
          if (targetProto == null) {
            return false;
          }
          targetProto = targetProto.__proto__;
        }
      };
      let arr = new Array();
      str = "";
      // console.log(arr);
      console.dir(arr);
      console.log(arr instanceof Array, _instanceof(arr, Array));
      console.log(str instanceof Array, _instanceof(str, Array));
      console.log(arr instanceof Object, _instanceof(arr, Object));
```
typeof 与 instanceof都是判断数据类型的方法，区别如下：
typeof 会返回一个变量的基本类型，instanceof 返回的是一个布尔值
instanceof  可以准确地判断复杂引用数据类型，但是不能正确判断基础数据类型
而 typeof 也存在弊端，它虽然可以判断基础数据类型（null 除外），但是引用数据类型中，除了function 类型以外，其他的也无法判断
因此可以用 Object.prototype.toString（）进行判断，返回一个 【Object ****】
```javascript
Object.prototype.toString({})       // "[object Object]"
Object.prototype.toString.call({})  // 同上结果，加上call也ok
Object.prototype.toString.call(1)    // "[object Number]"
Object.prototype.toString.call('1')  // "[object String]"
Object.prototype.toString.call(true)  // "[object Boolean]"
Object.prototype.toString.call(function(){})  // "[object Function]"
Object.prototype.toString.call(null)   //"[object Null]"
Object.prototype.toString.call(undefined) //"[object Undefined]"
Object.prototype.toString.call(/123/g)    //"[object RegExp]"
Object.prototype.toString.call(new Date()) //"[object Date]"
Object.prototype.toString.call([])       //"[object Array]"
Object.prototype.toString.call(document)  //"[object HTMLDocument]"
Object.prototype.toString.call(window)   //"[object Window]"
```
### 🔺继承

1.  借用构造函数继承父类
```javascript
function Father(uname, age) {
        this.uname = uname;
        this.age = age;
        this.work = function () {
          console.log("工作");
        };
      }

      function Son(uname, age) {
        Father.call(this); //让 子类中的this指向 父类
        this.uname = uname;
        this.age = age;
        this.study = function () {
          console.log("学习");
        };
      }

      let father = new Father("父类", 30);
      console.log(father.age);
      father.work();// 工作
      father.__proto__.work1 = function () {
        console.log("再工作");
      };
      father.work1();// 再工作
      console.log("===========");
      let son = new Son("儿子", 18);
      console.log(son.uname, son.age);// 男，18
      son.gender = "男";
      console.log(son.gender);// 男
      son.study();// 学习
      son.work();// 工作 
      son.work1();//work1 not  defined
```
缺点：所有方法都定义在构造函数中，无法做到函数复用，父类原型中定义的方法，子类访问不到，因为子类的实例只继承了父类的实例属性/方法，没有继承父类原型对象中的属性/方法。


2. 利用原型链的继承
```javascript
      function Father(uname) {
        this.uanme = uname;
        this.some = "yiixe";
        this.arr = [1, 2, 3, 4];
      }
      //把函数的方法定义到 原型 上
      Father.prototype.work = function () {
        console.log("工作");
      };

      function Son(uname) {
        this.uanme = uname;
      }
      Son.prototype = new Father();
      //这样 Son的原型里就没有了构造函数
      Son.prototype.constructor = Son;
      console.log(Son.prototype); //Father

      Son.prototype.study = function () {
        console.log("学习");
      };

      let father = new Father("父类1");
      let father2 = new Father("父类2");
      father.work(); //工作
      father2.work(); //工作

      let son = new Son("子类");
      let son1 = new Son("子类1");
      son.study(); //学习
      console.log(son.arr); //[1,2,3,4]
      son.arr.push(5);
      console.log(son1.arr); //[1,2,3,4,5]
      console.log(father.arr); //[1,2,3,4]
      son1.arr = [1, 2];
      console.log(son1.arr); //[1,2]
      console.log(father.arr); //[1,2,3,4]
```
缺点 ：① 如果Father定义了一个引用类型的属性，Son.prototype = new Father（）相当于 Son.prototype 变成了 Father的一个实例对象，从而相当于创建了Son.prototype.引用类型 这个属性 ，最后Son的所有实例都会通过地址访问这个属性的内容，如果对该引用类型属性进行修改，则其他的实例访问的该引用类型的内容都会改变。② 原型链的第二个问题是，子类型在实例化时不允许给父类型的构造函数传参，这样做不符合面向对象编程的规则：对象（实例）才是属性的拥有者。如果在子类定义时就将属性赋了值，就变成了类拥有属性，而不是对象拥有属性了。

3. 组合继承

原型链和借用构造函数的技术组合到一块
使用原型链实现对原型属性和方法的继承，而通过构造函数来实现对实例属性的继承。既通过在原型上定义方法实现了函数复用，又能够保证每个实例都有它自己的属性。



4. 寄生式继承



### new 构造函数的执行过程

1. 内存中创建一新的个空对象
1. 改变this指向，让this指向这个新的空对象
1. 执行构造函数里的代码，给这个新对象添加属性和方法
1. 返回新对象（因此构造函数里面不用return）

# 💡VUE
### main.js 的运行过程

1. 引入Vue对象（相当于引入vue.js）
1. 引入App.vue 对象
1. 实例化vue
1. 渲染App页面
1. 把页面渲染到 index.html 里，手动挂载到id为app的dom中。

### vue语法中的命令

1. 插值表达式：{ { } }

在 dom 中直接插入 vue 数据变量，数据变量在 js 中 data 函数里面声明

2. 给标签属性设置变量的值：v-bind / :

v-bind : 属性名 = “变量”

3. 给标签绑定事件 ： v-on / @click

v-on :  事件名 = “执行的代码”
v-on：事件名 = “函数名”
v-on：事件名 = “函数名（实参）”
事件中的 this 指向 exports default { } 中的变量

4. 事件修饰符：v-on : 事件名.修饰符 = ‘’函数‘’

   .prevent 阻止默认行为
    .stop 阻止冒泡
    .once 程序运行期间，只触发一次事件函数
          v-on : keyup.enter = ''函数''  监测回车
   v-on ：keyup.esc = ‘’函数‘’ 监测返回

5. 表单value和vue变量的双向绑定：v-model : ''vue变量''

下拉菜单 ，v-model绑定在select上 
复选框，v-model
（内容为非数组）：关联的是复选框的checked属性
 （内容为数组）：关联的是复选框的value值
v-model.修饰符 = “”

6. 



