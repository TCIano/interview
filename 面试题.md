# 💡CSS
### 🔺水平垂直居中一个元素

1. flex:主轴：
```javascript
justify-content：center
align-item：center
```

2. margin+定位：
```javascript
position:absolute
top:50%
left:50%
margin-left:width/2
margin-top:height/2
```

3. transform平面转换（translate）+定位
```javascript
position:absolute
top:50%
left:50%
translate：（-50%，-50%）
```

### CSS盒子模型

1. css盒子模型就是一个盒子：margin+border+padding+content

W3C（标准盒子模型）：
width /height = content

   1. 设置border/padding会使盒子变大
   1. box-sizing : content-box

IE（怪异盒子模型）
width/heigth = content + border +padding

   1. box-sizing ：border-box

### CSS3新属性

1. 文字阴影：	text-shadow :  水平  垂直  模糊距离  颜色
1. 圆角矩形：（长方形）border-radius ：height/2

正圆： （正方形）border-radius ：height/2
胶囊： （长方形）border-radius ：>=height/2
椭圆： （长方形）border-radius ：height/2
半圆：	（）border-radius ：**px(左上)	0(右上)	0(右下)	**px(左下) 

3. 盒子阴影：	box-shadow：水平  垂直  模糊距离  阴影大小  颜色	改变内侧阴影
3. 过渡动画：	(加在做动画的盒子上) 

transition：要改变的过渡属性/all(所有属性)		运动曲线(ease/linear)	延时

5. background-size：cover (让背景图完全撑满长和宽)

      contain(高/宽其中一个与盒子一致就停止缩放)

### 🔺BFC(块级格式化)
是一个独立的布局区域，子元素不会影响外界元素，
特点：在BFC中盒子沿着顶端垂直排列
作用：清除浮动
    解决外边距塌陷问题
开启：display：flow-root
inline-block
overflow：hidden
### flex布局(弹性布局)
开启：display：flex
主轴对齐方式：justify-content: space-between（每个盒子之间的距离一样）
space-around(每个盒子周围的空间)
space-evenly(平分剩余空间)
侧轴对齐方式：align-item: flex-start (起点开始默认)
flex-end(终点开始排列 )
center
      align-self:(某个盒子的侧轴对齐方式)
弹性盒子换行：flex-wrap：wrap；
wrap-reverse；（第一行在最后）

flex-grow :(定义放大比例)、flex-shrink(定义 缩小比例)、flex-basis(分配多余空间之前，子项目占据的主轴空间)
flex:auto = {flex-grow: 1;flex-shrink: 1;flex-basis:auto}
flex:none = {flex-grow: 0;flex-shrink: 0;flex-basis:auto}
flex:1 = {flex-grow: 1;flex-shrink: 1;flex-basis:0%}
flex：1 (更适合在等比例的列表中使用)
flex：auto(适用于元素充分利用的剩余空间，内部都一样才均分)

### 清除浮动

1. 给浮动元素的父级加  overflow：hidden
1. 在浮动的子元素最后加个空标签写 clear：both
1. 用after伪元素(相当于加一个空标签)
1. 给父级设置高度
### 🔺外边距塌陷解决

1. 给子元素加 position：absolute（变为行内块）
1. 父元素加overflow：hidden
1. 给父元素加border-top/padding-top
1. 设置浮动：display：float

# 💡html
### HTML5新特性

1. canvas(通过javascript图形绘制)
1. video和audio(音频视频标签)
1. 表单元素：datalist(选项列表，和input配合使用)，keygen(表单秘钥)，output(脚本输出)
1. 语义，结构元素：article(定义页面独立区域)，footer(页脚)，	header(文档头部区域)，nav(导航链接)，section(定义文档中的节)
1. 新技术：websocket(全双工通信)，webWorkers（Web应用程序可以在独立于主线程的后台线程中，运行一个脚本操作。这样做的好处是可以在独立线程中执行费时的处理任务，从而允许主线程（通常是UI线程）不会因此被阻塞/放慢），Geolocation（用户地理信息）
1. localstorage：本地存储，浏览器关闭后不会丢失
1. sessionstorage：浏览器关闭后数据消失
1. 离线应用：Cache manifest （进行web应用的缓存）
1. 移除了：basefont、big、center、font、s、strike、tt、u

frame、frameset、noframes
### 页面导入样式时，使用 link 和 @import 有什么区别

1. 从属关系：

@import 是 css 提供的语法规则，只有导入样式表的作用。
link 是html提供的标签不仅可以加载 css 文件，可以连接属性，引入网站图标

2. 加载顺序：

@import 引入的 css 将在页面加载完成后被加载。
加载页面时 link 引入的 css 也被同时加载

3. 兼容性：

@import  是 css 2.1 之后有的，只能在IE5及以上可用
link 没有兼容性问题

4. Dom可控性：

可以通过 JS 操作 DOM ，插入 link 标签来改变样式，由于 DOM 方法是基于文档的，无法使用 @import 的方式插入样式。

###  前端性能优化主要是为了提高页面的加载速度，优化用户的访问体验。我认为可以从这些方面来进行优化。

 第一个方面是页面的内容方面
 （1）通过文件合并、css 雪碧图、使用 base64 等方式来减少 HTTP 请求数，避免过多的请求造成等待的情况。
 （2）通过 DNS 缓存等机制来减少 DNS 的查询次数。
 （3）通过设置缓存策略，对常用不变的资源进行缓存。
 （4）使用延迟加载的方式，来减少页面首屏加载时需要请求的资源。延迟加载的资源当用户需要访问时，再去请求加载。
 （5）通过用户行为，对某些资源使用预加载的方式，来提高用户需要访问资源时的响应速度。
	
第二个方面是 CSS 和 JavaScript 方面
 （1）把样式表放在页面的 head 标签中，减少页面的首次渲染的时间。
 （2）避免使用 @import 标签。
 （3）尽量把 js 脚本放在页面底部或者使用 defer 或 async 属性，避免脚本的加载和执行阻塞页面的渲染。
 （4）通过对 JavaScript 和 CSS 的文件进行压缩，来减小文件的体积。

 第三个方面是服务器方面
 （1）使用 CDN 服务，来提高用户对于资源请求时的响应速度。
 （2）服务器端启用 Gzip、Deflate 等方式对于传输的资源进行压缩，减小文件的体积。
 （3）尽可能减小 cookie 的大小，并且通过将静态资源分配到其他域名下，来避免对静态资源请求时携带不必要的 cookie

 
### 🔺DOMContentLoaded事件/Load事件的区别？
DOMContentLoaded事件：HTML页面文档(DOM元素)加载和解析完毕后会触发，不需要等待样式表、图片、框架加载完毕。
Load：当所有资源加载玩比后触发。


# 💡js 
### 🔺JS的数据类型

- 栈：原始数据类型（Undefined、Null、Boolean、Number、String，symbol，BigInt）
- 堆：引用数据类型（对象、数组和函数，Date）

### 🔺原型对象，原型链

1. 原型

当我们用构造函数创建新对象时，函数的内部都有一个prototype属性，我们可以把函数的方法直接定义在prototype对象上，这样所有的对象的实例都可以共享这些方法。
每个被创建的实例对象内部都有一个__proto__属性，他们都指向各自的构造函数的prototype原型对象。

2. 原型链（就近原则）

当我们访问一个对象的属性或者方法的时候如果实例化对象内部没有这个属性和方法，我们就可以通过__proto__找到他的原型对象，如果还没有就找到原型对象的Object原型对象，直到找到null为止。

### 同源、同源策略、跨域

1. 同源：两个页面有相同的协议、域名、端口
1. 同源策略：是浏览器提供的一个安全策略，他规定了：
   1. 不可以读取非同源网站的Cookie、Localstorage、IndexedDB
   1. 无法获取非同源网页的DOM
   1. 无法向非同源地址发送Ajax请求
3. 跨域 ：浏览器的同源策略不允许非同源的URL之间进行交互

怎么跨域：JSONP ：缺点：只支持GET，不支持POST
     CORS：优：GET和POST都支持，
     缺：不兼容低版本浏览器
      开启反向代理服务器：一个网页通过访问反向代理服务器，间接的访问另
一个网页。

### 模块化开发
一个模块是对实现一个特定功能的一组方法的封装。在最开始的时候，js 只实现一些简单的功能，所以并没有模块的概念 ，但随着程序越来越复杂，代码的模块化开发变得越来越重要。
由于函数具有独立作用域的特点，最原始的写法是使用函数来作为模块，几个函数作为一个模块，但是这种方式容易造成全局变量的污染，并且模块间没有联系。 
后面提出了对象写法，通过将函数作为一个对象的方法来实现，这样解决了直接使用函数作为模块的一些缺点，但是这种办法会暴露所 有的所有的模块成员，外部代码可以修改内部属性的值。 
现在最常用的是立即执行函数的写法，通过利用闭包来实现模块私有作用域的建立，同时不会对全局作用域造成污染。

### JS中的几种模块化

1. commonJS：通过require来引入模块，通过module.exports来暴露（导出）模块的输出接口，它是一种服务器端的解决方法，在本地的用同步的方法引入模块 ，如果在浏览器端，由于模块的加载使用网络请求，那么用异步的方式加载更为合适。
1. AMD：采用异步加载的方式，加载模块，模块的加载不影响后面代码的执行，所有依赖这个模块的语句都定义在一个回调函数里，等到加载玩再执行回调函数，require.js就实现了AMD规范。
1. CMD：也是采用异步加载的方法，区别在于模块定义都时候对依赖的处理不同和对依赖模块的执行时机的处理不同。
1. ES6：用import和export的形式来导入和导出模块。

在编译时就完成模块的加载，效率要比 CommonJS 模块的加载方式高，这也导致了没法引用 ES6 模块本身，因为它不是对象。

### Set和Map数据结构

1. Set（类似于数组）

特点：成员的值唯一，没有重复的值，可以用来数组去重，[...new Set(array)]，可以接受数组或者伪数组作为参数。
声明：new Set（）	
方法：添加成员：add（）
    判断成员是否存在：has（）
    删除成员返回布尔：delete（）
    清除set：clear（）
    遍历set：foreach（）

2. WeakSet（和Set类似）

特点：首先成员只能是对象，其次WeakSet 中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中。
```javascript
let ws = new WeakSet();
      ws.add({
        name: "张三",
        age: 18,
      });
      ws.add({
        name: "李四",
        age: 20,
      });
      console.log(ws);
```
![image.png](https://cdn.nlark.com/yuque/0/2022/png/29071883/1655812443512-070157e2-68a8-43b1-9a19-7d8a83dae27e.png#clientId=u25ad8f7c-0ed8-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=146&id=uaabb66e9&margin=%5Bobject%20Object%5D&name=image.png&originHeight=182&originWidth=483&originalType=binary&ratio=1&rotation=0&showTitle=true&size=13486&status=done&style=none&taskId=u18c8fc3a-3d27-4b69-9e8b-01b3a7734ca&title=WeakSet%E7%BB%93%E6%9E%9C%E5%A6%82%E5%9B%BE&width=386.4 "WeakSet结果如图")

3. Map(像对象，但是键（key）能为任意类型的值)

声明：new Map（）
方法：添加成员：set（key，value）
    判断成员是否存在：has(key)
    获取成员的值：get（key）
    删除成员 ：delete（key）
    返回Map结构成员：size
    清除所有成员，没有返回值：clear（）
```javascript
let o = {
        userm: "wer",
      };
      let map = new Map();
      map.set(o, "age");
      console.log(map.get(o));
      console.log(map.has(o));
      //   map.delete(o);
      console.log(map);
```

![image.png](https://cdn.nlark.com/yuque/0/2022/png/29071883/1655880245884-985dd254-fe2d-45dc-ad16-1d1ab2134931.png#clientId=u0415d881-43bb-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=205&id=JFXgA&margin=%5Bobject%20Object%5D&name=image.png&originHeight=256&originWidth=308&originalType=binary&ratio=1&rotation=0&showTitle=true&size=13609&status=done&style=none&taskId=u201eaf28-6df8-4c52-b62c-100349460c1&title=Map%E6%93%8D%E4%BD%9C%E7%9A%84%E7%BB%93%E6%9E%9C&width=246.4 "Map操作的结果")

4. WeakMap（）

WeakMap只接受对象作为键名（null除外），不接受其他类型的值作为键名。
```javascript
// WeakMap 可以使用 set 方法添加成员
const wm1 = new WeakMap();
const key = {foo: 1};
wm1.set(key, 2);
wm1.get(key) // 2

// WeakMap 也可以接受一个数组，
// 作为构造函数的参数
const k1 = [1, 2, 3];
const k2 = [4, 5, 6];
const wm2 = new WeakMap([[k1, 'foo'], [k2, 'bar']]);
wm2.get(k2) // "bar"
```

### 🔺防抖和节流

1. 防抖：规定一个事件每隔n秒执行一次，如果在n秒内再次执行该事件，则重新开始计时。

防抖函数里面设置定时器，定时器里面做防抖函数的调用，如果在n秒内主动触发，则会重新调用计时器，重新开始计时。

2. 节流 ：规定一个事件在n秒内只能被触发一次，如果在n秒内再次触发，只有一次生效。

节流减少了一段时间内事件的触发频率。

### 🔺对象的深浅拷贝

1. 浅拷贝：

是将一个对象的属性值赋值给另一个对象，如果属性值为引用数据类型，那么会把该引用的地址复制给另一个对象，如果修改一个对象的引用类型的属性值，另一个对象也随之改变。
```javascript
var obj = {
        id: 1,
        name: "章三",
        msg: {
          age: 18,
        },
        color: ["red", "green", "yellow"],
      };

      var o = {};
      // 浅拷贝
      for (var k in obj) {
        o[k] = obj[k];
      }
      o.id = 66;
      o.color[0] = "123";//obj[0] == '123'
      console.log(o);
      console.log(obj);
```
```javascript
Object.assign(o, obj);//展开运算符，把obj浅拷贝给o
      o.id = 989;
      console.log(o);//id = 989
      console.log(obj);

```

1. 深拷贝

遇到属性值为引用类型的时候，它会新建一个引用类型并将对应的值复制给它，对象获得的一个新的引用类型而不是一个原有类型的引用。
```javascript
//深拷贝;
      function deepCopy(newObj, oldObj) {
        for (var k in oldObj) {
          //如果旧元素里面的元素是对象
          if (oldObj[k] instanceof Object) {
            newObj[k] = {};
            //再遍历对象，里面的元素，对里面元素进行判断
            deepCopy(newObj[k], oldObj[k]);
          }
          //如果里面的元素是数组
          else if (oldObj[k] instanceof Array) {
            //把新元素开辟一个数组空间用来存放旧元素
            newObj[k] = [];
            deepCopy(newObj[k], oldObj[k]);
          }
          //如果是简单数类型
          else {
            newObj[k] = oldObj[k];
          }
        }
      }
      deepCopy(o, obj);
      o.color[0] = "green";
      o.msg.age = 666;
      console.log(o);
      console.log(obj);
```
```javascript
let a = {
    age: 1,
    jobs: {
        first: 'FE'
    }
}
let b = JSON.parse(JSON.stringify(a))
a.jobs.first = 'native'
console.log(b.jobs.first) // FE
```
